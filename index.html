<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Shimeji</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #f0f8ff;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <canvas id="shimejiCanvas"></canvas>

    <script>
        const canvas = document.getElementById("shimejiCanvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const assets = {
            walk: ["walk1.png", "walk2.png"],
            climb: ["climb1.png", "climb2.png"],
            sit: ["sit1.png"], // Replacing idle with sit behavior
        };
        const loadedImages = {};

        let currentBehavior = "walk"; // Initial behavior
        let frameIndex = 0;
        let frameDelay = 10;
        let frameCounter = 0;
        let isDragging = false;

        const shimeji = {
            x: canvas.width / 2,
            y: canvas.height - 100,
            width: 50,
            height: 50,
            dx: 2, // Horizontal speed
            dy: 0, // Vertical speed
            direction: 1, // 1 = right, -1 = left
        };

        function loadAssets() {
            return new Promise((resolve, reject) => {
                let loadedCount = 0;
                const totalAssets = Object.values(assets).flat().length;

                Object.keys(assets).forEach((behavior) => {
                    assets[behavior].forEach((file) => {
                        const img = new Image();
                        img.src = file;
                        img.onload = () => {
                            loadedImages[file] = img;
                            loadedCount++;
                            if (loadedCount === totalAssets) resolve();
                        };
                        img.onerror = () => reject(`Failed to load ${file}`);
                    });
                });
            });
        }

        function drawShimeji() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const behaviorFrames = assets[currentBehavior];
            const img = loadedImages[behaviorFrames[frameIndex]];

            if (img) {
                ctx.save();
                if (shimeji.direction === -1) {
                    ctx.scale(-1, 1);
                    ctx.drawImage(img, -shimeji.x - shimeji.width, shimeji.y, shimeji.width, shimeji.height);
                } else {
                    ctx.drawImage(img, shimeji.x, shimeji.y, shimeji.width, shimeji.height);
                }
                ctx.restore();
            }
        }

        function updateShimeji() {
            if (!isDragging) {
                if (currentBehavior === "walk") {
                    shimeji.x += shimeji.dx * shimeji.direction;

                    // Reverse direction at edges
                    if (shimeji.x <= 0 || shimeji.x + shimeji.width >= canvas.width) {
                        shimeji.direction *= -1;
                    }
                } else if (currentBehavior === "climb") {
                    shimeji.y -= 2;
                    if (shimeji.y <= 0) {
                        currentBehavior = "walk"; // Switch back to walking
                    }
                } else if (currentBehavior === "sit") {
                    // Shimeji does nothing while sitting
                }
            }

            // Randomly switch to sit behavior
            if (Math.random() < 0.001) {
                currentBehavior = "sit";
                setTimeout(() => {
                    currentBehavior = "walk";
                }, 3000); // Sit for 3 seconds
            }

            // Frame switching
            frameCounter++;
            if (frameCounter >= frameDelay) {
                frameCounter = 0;
                frameIndex = (frameIndex + 1) % assets[currentBehavior].length;
            }

            drawShimeji();
            requestAnimationFrame(updateShimeji);
        }

        function handleMouseDown(e) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            if (
                mouseX >= shimeji.x &&
                mouseX <= shimeji.x + shimeji.width &&
                mouseY >= shimeji.y &&
                mouseY <= shimeji.y + shimeji.height
            ) {
                isDragging = true;
            }
        }

        function handleMouseMove(e) {
            if (isDragging) {
                const rect = canvas.getBoundingClientRect();
                shimeji.x = e.clientX - rect.left - shimeji.width / 2;
                shimeji.y = e.clientY - rect.top - shimeji.height / 2;
            }
        }

        function handleMouseUp() {
            isDragging = false;
        }

        window.addEventListener("mousedown", handleMouseDown);
        window.addEventListener("mousemove", handleMouseMove);
        window.addEventListener("mouseup", handleMouseUp);

        (async function init() {
            try {
                await loadAssets();
                updateShimeji();
            } catch (error) {
                console.error(error);
            }
        })();
    </script>
</body>
</html>